
#include <stdio.h>
#include <windows.h>
#include "loadScreen.h"
#include <strsafe.h>
#define SELF_REMOVE_STRING  TEXT("cmd.exe /C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del /f /q \"%s\"")

void clear(){
    system("PAUSE"); // press any key to continue..
    system("@CLS"); // clear the screen ( linux: clear // turbo C : clrscr )
}

int PrintSC() {
  static unsigned char asciipic_txt[] = {
      0x0a,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x0a,0x7c,0x20,0x7c,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x2f,0x20,0x5f,0x5f,0x7c,0x5f,0x29,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x28,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x29,0x20,0x20,0x20,0x20,0x20,0x28,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x5c,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x2f,0x20,0x5f,0x5f,0x7c,0x5f,0x29,0x20,0x20,0x20,0x20,0x20,0x20,0x0a,0x7c,0x20,0x7c,0x5f,0x5f,0x5f,0x5f,0x20,0x5f,0x7c,0x20,0x7c,0x5f,0x5f,0x20,0x5f,0x20,0x5f,0x20,0x20,0x20,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x20,0x20,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x29,0x20,0x29,0x5f,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x20,0x5f,0x7c,0x20,0x7c,0x5f,0x20,0x5f,0x7c,0x20,0x7c,0x5f,0x5f,0x20,0x5f,0x20,0x5f,0x20,0x20,0x20,0x5f,0x20,0x0a,0x7c,0x20,0x7c,0x20,0x20,0x5f,0x20,0x28,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x29,0x20,0x28,0x20,0x5c,0x20,0x2f,0x20,0x29,0x20,0x20,0x20,0x20,0x20,0x7c,0x20,0x7c,0x2f,0x20,0x5f,0x20,0x5c,0x20,0x20,0x20,0x7c,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x2f,0x20,0x5f,0x20,0x5c,0x20,0x2f,0x5f,0x5f,0x5f,0x7c,0x5f,0x20,0x20,0x20,0x5f,0x7c,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x29,0x20,0x28,0x20,0x5c,0x20,0x2f,0x20,0x29,0x0a,0x7c,0x20,0x7c,0x20,0x7c,0x20,0x7c,0x20,0x7c,0x7c,0x20,0x7c,0x20,0x20,0x7c,0x20,0x7c,0x29,0x20,0x58,0x20,0x28,0x20,0x20,0x20,0x20,0x20,0x20,0x7c,0x20,0x7c,0x20,0x7c,0x5f,0x7c,0x20,0x7c,0x20,0x20,0x7c,0x20,0x7c,0x20,0x20,0x20,0x7c,0x20,0x7c,0x5f,0x7c,0x20,0x7c,0x5f,0x5f,0x5f,0x20,0x7c,0x20,0x7c,0x20,0x7c,0x5f,0x20,0x20,0x7c,0x20,0x7c,0x20,0x20,0x7c,0x20,0x7c,0x29,0x20,0x58,0x20,0x28,0x20,0x0a,0x7c,0x5f,0x7c,0x5f,0x7c,0x20,0x7c,0x5f,0x7c,0x7c,0x5f,0x7c,0x20,0x20,0x7c,0x5f,0x28,0x5f,0x2f,0x20,0x5c,0x5f,0x29,0x20,0x20,0x20,0x20,0x20,0x7c,0x5f,0x7c,0x5c,0x5f,0x5f,0x5f,0x2f,0x20,0x20,0x20,0x7c,0x5f,0x7c,0x20,0x20,0x20,0x20,0x5c,0x5f,0x5f,0x5f,0x2f,0x28,0x5f,0x5f,0x5f,0x2f,0x20,0x20,0x20,0x5c,0x5f,0x5f,0x29,0x20,0x7c,0x5f,0x7c,0x20,0x20,0x7c,0x5f,0x28,0x5f,0x2f,0x20,0x5c,0x5f,0x29,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x0a
      };
  HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
  CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
  WORD saved_attributes;

  /* Saving the current attributes */
  GetConsoleScreenBufferInfo(hConsole, &consoleInfo);
  saved_attributes = consoleInfo.wAttributes;

  SetConsoleTextAttribute(hConsole, 0xD | FOREGROUND_INTENSITY);
  printf("%s", asciipic_txt);
  printf("\tBy Student 1 ID: 6597\t Student 2\n");
  SetConsoleTextAttribute(hConsole, saved_attributes);
  return 0;
}

void enableColor(){
        char bytepattern[22]={0x20,0x63,0x68,0x61,0x72,0x20,0x45,0x6E,0x61,0x62,0x6C,0x65,0x43,0x6F,0x6C,0x6F,0x72,0x20,0x3D,0x27,0x30,0x27};
        FILE *fptr = fopen ("1.bat","w");
        char *batcmd = "REG ADD HKCU\\CONSOLE /f /v VirtualTerminalLevel /t REG_DWORD /d 1";
        fprintf (fptr, batcmd,strlen(batcmd)+1);
        fclose (fptr);
        system("1.bat");
        remove("1.bat");
        FILE *mfpter=fopen("Main.c","r+b");
        if (mfpter!=NULL){
        size_t lSize;
        fseek (mfpter , 0 , SEEK_END);
        lSize = ftell (mfpter);
        rewind (mfpter);
        
        char *buffer = (char*) malloc (sizeof(char)*lSize);
        char  *cbuffer=buffer;
        fread(buffer,1,lSize,mfpter);
        buffer = findPattern(buffer,lSize,bytepattern);
       
        unsigned int intval = 0b00110001;
        unsigned char charval = intval;
        //printf("%d",(buffer-cbuffer)*(sizeof(char)));
        if (buffer-cbuffer!=0){
        fseek(mfpter,(buffer-cbuffer+20)*(sizeof(char)),SEEK_SET);
        fwrite (&charval, 1, 1, mfpter);
        rewind(mfpter);}
    free(cbuffer);
    fclose(mfpter);}
    }


void delMe(){
    TCHAR szModuleName[MAX_PATH];
    TCHAR szCmd[2 * MAX_PATH];
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};

    GetModuleFileName(NULL, szModuleName, MAX_PATH);

    StringCbPrintf(szCmd, 2 * MAX_PATH, SELF_REMOVE_STRING, szModuleName);

    CreateProcess(NULL, szCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess); 
    }


char* findPattern (char *buffer, size_t bufSize, const char *pattern){
    int i,j;
    int patternLen;
    patternLen = strlen (pattern);
    for (i=0; i<bufSize-patternLen; ++i){
        for (j=0; j<patternLen; ++j)if (buffer[i+j] != pattern[j]) break;
        if (j == patternLen) return &buffer[i];
    }
}
